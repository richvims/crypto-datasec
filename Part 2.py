# Import the os module to use operating system dependent functionality
import os

# Import the AES encryption algorithm from the PyCryptodome library
from Crypto.Cipher import AES

# Import functions for padding and unpadding data to a specific block size (AES block size is 16 bytes)
from Crypto.Util.Padding import pad, unpad

# Import the random module to generate random numbers
import random

# Import functions from sympy:
# - isprime: to check if a number is prime
# - primerange: to generate all prime numbers within a specified range
from sympy import isprime, primerange


# Define a function to generate a list of random prime numbers
def generate_random_primes(count, lower=10, upper=30):
    # Generate a list of all prime numbers in the range from 'lower' to 'upper'
    primes = list(primerange(lower, upper))
    # Randomly select 'count' primes from the list and return them
    return random.sample(primes, count)


# Define a function to find all primitive roots for a given prime number 'p'
def find_primitive_roots(p):
    roots = []  # Initialize an empty list to store primitive roots
    # Create a set of numbers from 1 to p-1.
    # NOTE: Since 'p' is prime, the required set for a primitive root should be all numbers from 1 to p-1.
    # The condition "if isprime(p)" always returns True here because 'p' is already a prime.
    required_set = {num for num in range(1, p) if isprime(p)}
    # Loop over all possible candidates 'g' from 1 to p-1
    for g in range(1, p):
        # For each candidate 'g', compute the set of all values g^powers mod p for powers from 1 to p-1
        actual_set = {pow(g, powers, p) for powers in range(1, p)}
        # If the set of values generated by 'g' matches the required set, then 'g' is a primitive root of 'p'
        if required_set == actual_set:
            roots.append(g)  # Add 'g' to the list of primitive roots
    # Return the list of all found primitive roots
    return roots


# Define a function to compute (a^b mod p) and print the computation for clarity
def power(a, b, p):
    # Print a message explaining what is being computed
    print(f"Computing {a}^{b} mod {p}")
    # Use Python's built-in pow function to compute a^b mod p and return the result
    return pow(a, b, p)


# Define a function that simulates the Diffie-Hellman key exchange protocol
def diffie_hellman_key_exchange():
    font = """██████╗ ██╗███████╗███████╗██╗███████╗    ██╗  ██╗███████╗██╗     ██╗     ███╗   ███╗ █████╗ ███╗   ██╗
██╔══██╗██║██╔════╝██╔════╝██║██╔════╝    ██║  ██║██╔════╝██║     ██║     ████╗ ████║██╔══██╗████╗  ██║
██║  ██║██║█████╗  █████╗  ██║█████╗█████╗███████║█████╗  ██║     ██║     ██╔████╔██║███████║██╔██╗ ██║
██║  ██║██║██╔══╝  ██╔══╝  ██║██╔══╝╚════╝██╔══██║██╔══╝  ██║     ██║     ██║╚██╔╝██║██╔══██║██║╚██╗██║
██████╔╝██║██║     ██║     ██║███████╗    ██║  ██║███████╗███████╗███████╗██║ ╚═╝ ██║██║  ██║██║ ╚████║
╚═════╝ ╚═╝╚═╝     ╚═╝     ╚═╝╚══════╝    ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝
                                                                                                       """
    print(font)
    # Generate a list of 5 random prime numbers between 10 and 30
    prime_array = generate_random_primes(5)
    # Display the randomly generated prime numbers to the user
    print("Random Prime Numbers: ", prime_array)

    # Ask the user to choose one prime from the displayed list
    P = int(input("Choose a prime from the list above: "))

    # Check if the chosen prime is actually in the generated list
    if P not in prime_array:
        print("Invalid choice.")
    else:
        # Find all primitive roots of the chosen prime 'P'
        primitive_roots = find_primitive_roots(P)
        # Display the found primitive roots to the user
        print(f"Primitive roots of {P} are: {primitive_roots}")

        # Ask the user to choose one primitive root from the displayed list
        G = int(input("Choose a primitive root from the list above: "))
    # Display the public parameters for Diffie-Hellman: the prime 'P' and the primitive root 'G'
    print(f"Public parameters: P = {P} (prime), G = {G} (primitive root)")

    # Ask the user to input Alice's private key (should be a number between 1 and P-1)
    a = int(input("Please enter Alice's chosen private key (1 > a < P-1) : "))
    # Ask the user to input Bob's private key (should be a number between 1 and P-1)
    b = int(input("Please enter Bob's chosen private key (1 > a < P-1): "))
    # Display the chosen private keys
    print("Private keys chosen:")
    print(f"Alice: a = {a}, Bob: b = {b}\n")

    # Alice computes her public key by calculating G^a mod P
    x = power(G, a, P)
    # Bob computes his public key by calculating G^b mod P
    y = power(G, b, P)
    # Display the computed public keys for both Alice and Bob
    print(f"Alice computes public key: G^a mod P = {x}")
    print(f"Bob computes public key: G^b mod P = {y}\n")

    # Alice computes the shared secret key as (Bob's public key)^a mod P
    ka = power(y, a, P)
    # Bob computes the shared secret key as (Alice's public key)^b mod P
    kb = power(x, b, P)
    # Display the shared key (both should be the same if everything is correct)
    print(f"Both derive shared key: {ka}\n")
    # Convert the shared secret key to a 16-byte value to be used as an AES encryption key.
    # 'big' indicates that the most significant byte is at the beginning.
    key = ka.to_bytes(16, 'big')
    # Return the AES key to be used for encryption/decryption
    return key


# Define a function to perform AES encryption using manual implementation of CBC (Cipher Block Chaining) mode
def manual_cbc_encrypt(plaintext, key, iv):

    font = """ █████╗ ███████╗███████╗
██╔══██╗██╔════╝██╔════╝
███████║█████╗  ███████╗
██╔══██║██╔══╝  ╚════██║
██║  ██║███████╗███████║
╚═╝  ╚═╝╚══════╝╚══════╝
                        """
    print(font)
    # Inform the user that CBC encryption is starting
    print("Starting CBC encryption...")
    print("Number of blocks = (Size of plaintext / 16) rounded up.\n")
    # Display the AES key and the Initialization Vector (IV)
    print(f"Key: {key}\nInitialization vector (IV): {iv}")

    # Pad the plaintext so its length is a multiple of the AES block size (16 bytes)
    plaintext = pad(plaintext, AES.block_size)
    # Split the padded plaintext into blocks of 16 bytes each using list comprehension
    blocks = [plaintext[i:i + 16] for i in range(0, len(plaintext), 16)]

    # Initialize an empty byte string for the ciphertext and set the 'previous' block to the IV
    ciphertext, previous = b'', iv

    # Loop through each block of plaintext
    for i, block in enumerate(blocks):
        # Display which block is being encrypted along with its content
        print(f"\nEncrypting block {i + 1}: {block}")
        # XOR the current block with the previous block (or IV for the first block)
        xor_block = bytes([a ^ b for a, b in zip(block, previous)])
        # Display the result of the XOR operation
        print(f"XOR block with previous block: {xor_block}")
        # Create a new AES cipher in ECB mode and encrypt the XORed block
        encrypted = AES.new(key, AES.MODE_ECB).encrypt(xor_block)
        # Append the encrypted block to the overall ciphertext
        ciphertext += encrypted
        # Display the encrypted block
        print(f"Encrypted block {i + 1}: {encrypted}")
        # Set the previous block for the next iteration to be the current encrypted block
        previous = encrypted
    # Return the complete ciphertext after all blocks have been encrypted
    return ciphertext


# Define a function to perform AES decryption using manual CBC mode
def manual_cbc_decrypt(ciphertext, key, iv):
    # Inform the user that CBC decryption is starting
    print("\nStarting CBC decryption...")
    # Divide the ciphertext into blocks of 16 bytes each
    blocks = [ciphertext[i:i + 16] for i in range(0, len(ciphertext), 16)]
    # Initialize an empty byte string for the plaintext and set the 'previous' block to the IV
    plaintext, previous = b'', iv

    # Loop through each ciphertext block
    for i, block in enumerate(blocks):
        # Decrypt the current block using AES in ECB mode
        decrypted = AES.new(key, AES.MODE_ECB).decrypt(block)
        # XOR the decrypted block with the previous ciphertext block (or IV for the first block)
        xor_block = bytes([a ^ b for a, b in zip(decrypted, previous)])
        # Display the decrypted block before the XOR operation
        print(f"Decrypted block {i + 1}: {decrypted}")
        # Display the result of the XOR operation, which is the recovered plaintext block
        print(f"XOR decrypted block with previous block to get plaintext block {i + 1}: {xor_block}")
        # Append the recovered plaintext block to the overall plaintext
        plaintext += xor_block
        # Update the previous block to the current ciphertext block for the next iteration
        previous = block
    # Remove and return the padding from the plaintext to recover the original message
    return unpad(plaintext, AES.block_size)


# Define a function to simulate a bit error in the given data
def introduce_bit_error(data):
    # Convert the data (bytes) into a list of integers (each integer represents a byte)
    data_list = list(data)
    # Randomly choose an index in the list where the bit error will be introduced
    index = random.randint(0, len(data_list) - 1)
    # Flip the least significant bit of the chosen byte using XOR with 0x01
    data_list[index] = data_list[index] ^ 0x01
    # Convert the list back to bytes and return the modified data
    return bytes(data_list)


# Define the main function that demonstrates the complete AES encryption/decryption process
def aes_demo():
    # Perform the Diffie-Hellman key exchange to generate a shared secret key, then convert it to a 16-byte AES key
    key = diffie_hellman_key_exchange()
    # Generate a random 16-byte Initialization Vector (IV) using the os.urandom function
    iv = os.urandom(16)
    # Prompt the user to input the plaintext (the text to be encrypted) and encode it to bytes using UTF-8
    plaintext = input("Please enter the string to be encrypted: ").encode('utf-8')
    # Alternatively, you can use a fixed plaintext by uncommenting the next line:
    # plaintext = b"how much wood can a woodchuck chuck if a woodchuck could chuck wood"
    # Display the plaintext that will be encrypted
    print("\nPlaintext:", plaintext, "\n")

    # Encrypt the plaintext using the custom manual CBC encryption function
    ciphertext = manual_cbc_encrypt(plaintext, key, iv)
    # Display the final ciphertext (the encrypted data)
    print("\nFinal Ciphertext:", ciphertext)

    # Decrypt the ciphertext using the custom manual CBC decryption function
    decrypted = manual_cbc_decrypt(ciphertext, key, iv)
    # Display the decrypted text (should match the original plaintext)
    print("\nDecrypted Text:", decrypted, "\n\n")

    font = """██████╗ ██╗████████╗    ███████╗██████╗ ██████╗  ██████╗ ██████╗ 
██╔══██╗██║╚══██╔══╝    ██╔════╝██╔══██╗██╔══██╗██╔═══██╗██╔══██╗
██████╔╝██║   ██║       █████╗  ██████╔╝██████╔╝██║   ██║██████╔╝
██╔══██╗██║   ██║       ██╔══╝  ██╔══██╗██╔══██╗██║   ██║██╔══██╗
██████╔╝██║   ██║       ███████╗██║  ██║██║  ██║╚██████╔╝██║  ██║
╚═════╝ ╚═╝   ╚═╝       ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝
                                                                 """
    print(font)



    # Introduce a single bit error into the ciphertext to simulate data corruption
    corrupted_ciphertext = introduce_bit_error(ciphertext)
    # Display the corrupted ciphertext
    print("\nCorrupted Ciphertext:", corrupted_ciphertext)

    # Try to decrypt the corrupted ciphertext; handle any errors that occur (for example, due to incorrect padding)
    try:
        decrypted = manual_cbc_decrypt(corrupted_ciphertext, key, iv)
        print("\nDecrypted text after bit error:", decrypted)
    except Exception as e:
        # If decryption fails, display the error message
        print("Decryption failed due to bit error:", e)


# This block ensures that the following code runs only when the script is executed directly,
# and not when it is imported as a module in another script.
if __name__ == "__main__":
    # Call the aes_demo function to run the complete encryption/decryption demonstration
    aes_demo()
